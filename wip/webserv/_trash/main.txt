/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ecaceres <ecaceres@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/10/19 15:34:02 by ecaceres          #+#    #+#             */
/*   Updated: 2020/10/19 15:34:02 by ecaceres         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <arpa/inet.h>
#include <config/block/ServerBlock.hpp>
#include <config/Configuration.hpp>
#include <exception/IOException.hpp>
#include <http/HttpRequestParser.hpp>
#include <http/HttpResponse.hpp>
#include <http/HTTPHeaderFields.hpp>
#include <http/HTTPMethod.hpp>
#include <http/HTTPOrchestrator.hpp>
#include <http/HTTPStatus.hpp>
#include <http/HTTPVersion.hpp>
#include <http/mime/MimeRegistry.hpp>
#include <netinet/in.h>
#include <sys/_endian.h>
#include <sys/_select.h>
#include <sys/_types/_fd_clr.h>
#include <sys/_types/_fd_def.h>
#include <sys/_types/_fd_isset.h>
#include <sys/_types/_fd_set.h>
#include <sys/_types/_fd_zero.h>
#include <sys/_types/_timeval.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>
#include <util/ContainerBuilder.hpp>
#include <util/unit/DataSize.hpp>
#include <cstring>
#include <iostream>
#include <map>
#include <string>
#include <vector>

class DataSize;

#if 1
#include <sstream>
#endif

template<class T>
	inline std::string
	to_string(const T &t)
	{
		std::stringstream ss;
		ss << t;
		return ss.str();
	}

class JSONParser;

//int
//main654(int argc, char **argv)
//{
//	Logger &log = Logger::factory("main");
//
//	SocketServer server;
//	server.bind(1502);
//	server.listen();
//
//	fd_set fds;
//
//	FD_ZERO(&fds);
//	FD_SET(server.fd(), &fds);
//
//	fd_set read_fds;
//	fd_set write_fds;
//
//	int highest = server.fd();
//	int startAt = highest + 1;
//
//	log.info() << "Server started on port: " << server.port() << std::endl;
//
//	std::map<int, HttpRequest*> connected;
//
//	while (1)
//	{
//		read_fds = fds;
//		write_fds = fds;
//
//		//		log.info() << "Selecting... " << std::endl;
//		//		log.info() << "Highest: " << highest << std::endl;
//		if (::select(highest + 1, &read_fds, &write_fds, NULL, NULL) == -1)
//			throw IOException("select", errno);
//
//		if (FD_ISSET(server.fd(), &read_fds))
//		{
//			try
//			{
//				Socket socket = server.accept();
//
//				std::cout << "received: " << socket.fd() << std::endl;
//
//				if (socket.fd() > highest)
//					highest = socket.fd();
//
//				FD_SET(socket.fd(), &fds);
//
//				connected.insert(connected.end(), std::make_pair(socket.fd(), new HttpRequest(socket)));
//			}
//			catch (Exception &e)
//			{
//				std::cout << e.what() << std::endl;
//			}
//		}
//
//		for (int idx = startAt; idx < highest; idx++)
//		{
//			if (!FD_ISSET(idx, &read_fds))
//				continue;
//
//			std::map<int, HttpRequest*>::iterator it = connected.find(idx);
//			if (it == connected.end())
//			{
//				log.warn() << "Orphane FD: " << idx << std::endl;
//				FD_CLR(idx, &fds);
//				close(idx);
//			}
//			else
//			{
//				if (it->second->read())
//				{
//					FD_CLR(idx, &fds);
//					connected.erase(it);
//				}
//
//				IOException::check();
//			}
//		}
//	}
//
//	server.close();
//
//	return (EXIT_SUCCESS);
//}

//typedef enum
//{
//	CS_CONNECTED = 1,
//	CS_HEADER,
//	CS_BODY,
//	CS_ERROR
//} client_status;
//
//typedef struct
//{
//		client_status status;
//		std::string line;
//		HttpRequestParser parser;
//		bool header_read;
//		unsigned long last_action;
//		HttpResponse *response;
//} client;
//
//unsigned long
//seconds()
//{
//	struct timeval val;
//	if (gettimeofday(&val, NULL))
//		return (0);
//
//	return (val.tv_sec);
//}

int
main(int argc, char **argv)
{
	HTTPMethod::loadDefaults();

	Configuration configuration(ContainerBuilder<ServerBlock>() //
	/* */.add(ServerBlock()
	/* *//* */.port(1502)
	/* *//* */.host("127.0.0.1")
	/* *//* */.name("boxplay.io")
	/* *//* */.maxBodySize(DataSize::ofMegabytes(10))
	/* *//* */.root("/var/www/html"))
	/* */.add(ServerBlock()
	/* *//* */.port(2051)
	/* *//* */.host("127.0.0.1")
	/* *//* */.name("boxplay2.io")
	/* *//* */.maxBodySize(DataSize::ofMegabytes(10))
	/* *//* */.root("/var/www/html"))
	/* */.build());

	HTTPOrchestrator::create(configuration).start();
//
////	std::cout << DataSize::parse("1024").toBytes() << std::endl;
//
//	MimeRegistry mimeRegistry;
//	mimeRegistry.loadFromFile("mime.map");
//
////	HTTPStatus::iterator it = HTTPStatus::values().begin();
////	HTTPStatus::iterator ite = HTTPStatus::values().end();
////
////	while (it != ite)
////	{
////		std::cout << (*it)->ordinal() << ": " << (*it)->name() << std::endl;
////		it++;
////	}
////
////	std::cout << *(mimeRegistry.findByMimeType("video/mp4")->extensions().begin()) << std::endl;
//
//	(void)argc;
//	(void)argv;
//
//	const int port = 1502;
//	int server_fd = ::socket(AF_INET, SOCK_STREAM, 0);
//
//	int _true = 1;
//	if (::setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &_true, sizeof(int)) == -1)
//		throw IOException("setsockopt", errno);
//
//	if (::fcntl(server_fd, F_SETFL, O_NONBLOCK) == -1)
//		throw IOException("fcntl", errno);
//
//	std::cout << "setsockopt" << std::endl;
//
//	struct sockaddr_in m_addr;
//
//	::memset(&m_addr, 0, sizeof(m_addr));
//
//	m_addr.sin_family = AF_INET;
//	m_addr.sin_addr.s_addr = ::inet_addr("0.0.0.0");
//	m_addr.sin_port = htons(port);
//
//	if (::bind(server_fd, (struct sockaddr*)&m_addr, sizeof(m_addr)) == -1)
//		throw IOException("bind", errno);
//
//	std::cout << "bind" << std::endl;
//
//	if (::listen(server_fd, 50) == -1)
//		throw IOException("listen", errno);
//
//	std::cout << "listen" << std::endl;
//
//	fd_set fds;
//
//	FD_ZERO(&fds);
//	FD_SET(server_fd, &fds);
//
//	fd_set read_fds;
//	fd_set write_fds;
//
//	int highest = server_fd;
//	int startAt = highest + 1;
//
//	std::map<int, client*> clients;
//
//	while (1)
//	{
//		read_fds = fds;
//		write_fds = fds;
//
//		if (::select(highest + 1, &read_fds, &write_fds, NULL, NULL) == -1)
//			throw IOException("select", errno);
//
//		if (FD_ISSET(server_fd, &read_fds))
//		{
//			try
//			{
//				int socket_fd = ::accept(server_fd, NULL, NULL);
//
//				std::cout << "connected(" << socket_fd << ")" << std::endl;
//
//				if (::fcntl(socket_fd, F_SETFL, O_NONBLOCK) == -1)
//					throw IOException("fcntl", errno);
//
//				if (socket_fd > highest)
//					highest = socket_fd;
//
//				FD_SET(socket_fd, &fds);
//
//				client *c = new client();
//				c->status = CS_CONNECTED;
//				c->last_action = seconds();
//				c->header_read = false;
//
//				clients[socket_fd] = c;
//			}
//			catch (Exception &e)
//			{
//				std::cout << e.what() << std::endl;
//			}
//		}
//
////		std::cout << " READ: ";
////		for (int i = 0; i < 64; i++)
////			std::cout << (FD_ISSET(i, &read_fds) ? 1 : 0);
////		std::cout << std::endl;
////
////		std::cout << "WRITE: ";
////		for (int i = 0; i < 64; i++)
////			std::cout << (FD_ISSET(i, &read_fds) ? 1 : 0);
////		std::cout << std::endl;
////
////		std::cout << "     : " << startAt << " < " << highest << std::endl;
//
//		unsigned long now = seconds();
//
//		for (int fd = startAt; fd <= highest; fd++)
//		{
//			if (!FD_ISSET(fd, &fds))
//				continue;
//
//			std::map<int, client*>::iterator it = clients.find(fd);
//
//			if (it == clients.end())
//			{
//				std::cout << "orphane: " << fd << std::endl;
//				::close(fd);
//				FD_CLR(fd, &fds);
//				clients.erase(it);
//				continue;
//			}
//
//			bool canRead = FD_ISSET(fd, &read_fds);
//			bool canWrite = FD_ISSET(fd, &write_fds);
//
//			client *cli = it->second;
//
//			if (cli->last_action + 5 < now)
//			{
//				std::cout << "timeout: " << fd << std::endl;
//				::close(fd);
//				FD_CLR(fd, &fds);
//				delete cli;
//				clients.erase(it);
//
//				continue;
//			}
//
//			if (canRead && !cli->header_read)
//			{
//				char c;
//				if (::recv(fd, &c, 1, 0) > 0)
//				{
////					if (c == '\n')
////						std::cout << "\\n\n";
////					else if (c == '\r')
////						std::cout << "\\r";
////					else
////						std::cout << c;
////					std::cout << std::flush;
//
//					if (c)
//					{
//						cli->parser.consume(c);
//						if (cli->parser.state() == HttpRequestParser::S_END && !cli->response)
//						{
////							std::cout << cli->parser.method() << std::endl;
////							std::cout << cli->parser.path() << std::endl;
////							std::cout << cli->parser.major() << std::endl;
////							std::cout << cli->parser.minor() << std::endl;
//
//							std::string file = cli->parser.path().substr(1);
//
//							int ffd = ::open(("." + cli->parser.path()).c_str(), O_RDONLY);
//
////
////#define SENDD(msg) x = msg + std::string(""); send(fd, x.c_str(), x.length(), 0);
////							std::string x;
////							if (ffd == -1)
////							{
////								SENDD("HTTP/1.1 404 Not Found\r\n");
////								SENDD("Server: webserv\r\n");
////								SENDD("Content-Length: 8\r\n");
////								SENDD("Content-Type: text/html; charset=iso-8859-1\r\n");
////								SENDD("\r\n");
////								SENDD("fuck you");
////
////								std::cout << strerror(errno) << std::endl;
////							}
////							else
////							{
////								SENDD("HTTP/1.1 200 OK\r\n");
////								SENDD("Server: webserv\r\n");
////								SENDD("Content-Type: " + mimeRegistry.findByFileExtension(file.substr(file.find(".") + 1))->type() + "\r\n");
////
////								struct stat st;
////								::stat(("." + cli->parser.path()).c_str(), &st);
////								long long size = st.st_size;
////								SENDD("Content-Length: " + to_string(size) + "\r\n");
////								SENDD("\r\n");
////
////								unsigned char buff[200];
////								ssize_t r;
////								while ((r = ::read(ffd, buff, sizeof(buff))) > 0)
////									::send(fd, buff, r, 0);
////
////								::close(ffd);
////							}
//
//							HTTPHeaderFields header;
//							header.date();
//							header.set("Server", "webserv");
//
//							struct stat st;
//							if (ffd == -1 || ::stat(("." + cli->parser.path()).c_str(), &st) == -1)
//							{
//								header.contentType("text/html");
//								header.contentLength(8);
//								std::cout << "GET " + cli->parser.path() + " -> 404" << std::endl;
//								close(ffd);
//							}
//							else
//							{
//								header.contentType(mimeRegistry, file.substr(file.rfind(".") + 1));
//								header.contentLength(st.st_size);
//								std::cout << "GET " + cli->parser.path() + " -> 200" << std::endl;
//							}
//
//							cli->response = new HttpResponse(HTTPVersion::HTTP_1_1, *HTTPStatus::OK, header, new HttpResponse::FileBody(ffd));
//						}
//					}
//				}
////				std::cout << "can read(" << fd << ")" << std::endl;
//			}
//
//			if (canWrite)
//			{
//				if (cli->response)
//				{
//					if (cli->response->write(fd) <= 0)
//					{
//						::close(fd);
//						FD_CLR(fd, &fds);
//						delete cli->response;
//						delete cli;
//						clients.erase(it);
//					}
//				}
////				send(fd, "Hello\n", 6, 0);
////				std::cout << "can write(" << fd << ")" << std::endl;
//			}
//		}
//	}

//	close(server_fd);
}

//int
//main(int argc, char **argv)
//{
//#define ass(cond) \
//	if (!(cond)) std::cout << #cond << std::endl;
//
//	JSONParser parser("132.5asd");
//	try
//	{
//		std::cout << "parsed: " << parser.parse().toJsonString() << std::endl;
//		std::cout << "done" << std::endl;
//	}
//	catch (JSONException &e)
//	{
//		std::cout << std::endl << e.source() << std::endl;
//		if (e.index() != -1)
//		{
//			for (size_t i = 0; i < e.index(); i++)
//				std::cout << " ";
//			std::cout << "^" << " (" << e.index() << ")" << std::endl;
//		}
//
//		std::cout << std::endl << e.what() << std::endl;
//
//		void *array[10];
//		size_t size;
//		size = backtrace(array, 10);
//		backtrace_symbols_fd(array, size, 1);
//	}
//}

